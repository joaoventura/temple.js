{"name":"Temple.js","tagline":"Sane web development with templates","body":"\r\nTemple.js is a small javascript library which helps you with the development of your templates.\r\n\r\nYou declare your templates inline or on external files, and use temple.js to load and compile them for you. When you are ready for production, compile your templates to javascript source code, and let temple.js get out of your way.\r\n\r\nTemple.js templates support Javascript logic inside. You can declare variables, invoke functions and use for loops inside the templates. They are pretty powerfull!\r\n\r\n\r\n## Basic Usage\r\n\r\n### During development\r\n\r\nDeclare your templates inline in your HTML or on an external file. Each template must have a name and an argument.\r\n\r\n```html\r\n\r\n<template name='message' arg='name'>\r\n    <li>Hello {{=name}}</li>\r\n</template>\r\n\r\n<template name='greet' arg='names'>\r\n    <ul>\r\n    {{for (var i=0; i<names.length; i++) { }}\r\n        {{=this.message(names[i])}}\r\n    {{ } }}\r\n    </ul>\r\n</template>\r\n\r\n```\r\n\r\nUse temple.js to load your templates and use them.\r\n\r\n```javascript\r\n\r\ntemple.fromURL('templates.html', function (templates) {\r\n    var string = templates.greet(['Andrew', 'Betty', 'Charles']);\r\n});\r\n\r\n```\r\n\r\n```html\r\n<ul>\r\n    <li>Hello Andrew</li>\r\n    <li>Hello Betty</li>\r\n    <li>Hello Charles</li>\r\n</ul>\r\n\r\n```\r\n\r\nYou can also use the templates inline with your HTML, using `temple.fromID(id)` for retrieving the templates from an element with ID *id*.\r\n*Check the samples for more examples.*\r\n\r\n\r\n### For production\r\n\r\nUse temple.js to generate the javascript source code of your templates.\r\n\r\n\r\n```javascript\r\n\r\ntemple.sourceFromURL('templates.html', 'mytemplates', function (source) {\r\n    console.log(source);\r\n});\r\n\r\n```\r\n\r\nThis will print the template's source code to the console.\r\n\r\n```javascript\r\n\r\nvar mytemplates = {};\r\n\r\nmytemplates.message = function (name) {\r\n    var out = '<li>Hello ' + (name) + '</li>';\r\n    return out;\r\n};\r\n\r\nmytemplates.greet = function (names) {\r\n    var out = '<ul>';\r\n    for (var i = 0; i < names.length; i++) {\r\n        out += (this.message(names[i]));\r\n    }\r\n    out += '</ul>';\r\n    return out;\r\n};\r\n\r\n\r\n```\r\n\r\nJust copy-paste this source code into a new javascript file (or inline in your HTML) and use it directly on your own javascript code. There's no more need for temple.js in your project.\r\n\r\n```javascript\r\n\r\nvar string = mytemplates.greet(['Andrew', 'Betty', 'Charles']);\r\n\r\n```\r\n\r\n\r\nIn alternative, you can use [this online generator](http://joaoventura.github.io/temple.js/generator/index.html) to compile your templates to javascript source code.\r\n\r\n\r\n\r\n\r\n## Documentation\r\n\r\n\r\n### Templates\r\n\r\nA template is defined as a string between a <template> tag and includes two attributes - the template name and the template argument. Temple.js only accepts one argument per template.\r\n\r\n```html\r\n<template name='message' arg='name'>\r\n    <li>Hello {{=name}}</li>\r\n</template>\r\n```\r\n\r\nThe previous template gets compiled to the following javascript function:\r\n\r\n```javascript\r\nfunction message(name) {\r\n    var out = '<li>Hello ' + (name) + '</li>';\r\n    return out;\r\n};\r\n```\r\n\r\nInternally, temple.js just compiles templates to functions. During development of your templates, it does it automatically for you, and for production you just grab your template's javascript source code.\r\n\r\n\r\n### Functions\r\n\r\nBesides templates, you can also define functions that can be useful, for instance, for defining presentation logic.\r\nThe main difference between functions and templates, is that the content of functions must be pure javascript code. But, similarly to templates, functions must have a name and an argument. For instance,\r\n\r\n```html\r\n<function name='beautify' arg='someone'>\r\n    var x = 0;\r\n    return \"Hi\" + someone + \" you are beautiful!\";\r\n</function>\r\n```\r\n\r\ngets compiled to:\r\n\r\n```javascript\r\nfunction beautify(someone) {\r\n    var x = 0;\r\n    return \"Hi\" + someone + \" you are beautiful!\";\r\n};\r\n```\r\n\r\nBasically, temple.js returns the contents of functions as they are defined.\r\n\r\n\r\n### Template logic\r\n\r\nSince templates will eventually get compiled to javascript source code, this means that you can use javascript code inside your templates. This is a very powerfull mechanism.\r\n\r\n```html\r\n<template name='message' arg='name'>\r\n    {{var someNumber = Math.random();}}\r\n    {{var idiot = name + ' is idiot!';}}\r\n    <li>Hello {{=idiot}}</li>\r\n</template>\r\n```\r\n\r\nThe previous template gets compiled to the following javascript function:\r\n\r\n```javascript\r\nfunction message(name) {\r\n    var out = '';\r\n    var someNumber = Math.random();\r\n    var idiot = name + ' is idiot!';\r\n    out += '<li>Hello ' + (idiot) + '</li>';\r\n    return out;\r\n};\r\n\r\n```\r\nNotice the *semicolon* after the variable declarations and function calls, and the *equal sign* when we want to use a variable or a function's result as string and concatenate it to the return variable `out`.\r\n\r\nAnother powerfull mechanism is the invocation of sub templates in your templates. This allows you to modularize your code.\r\n\r\n```html\r\n\r\n<template name='message' arg='name'>\r\n    <li>Hello {{=name}}</li>\r\n</template>\r\n\r\n<template name='greet' arg='names'>\r\n    <ul>\r\n    {{for (var i=0; i<names.length; i++) { }}\r\n        {{=this.message(names[i])}}\r\n    {{ } }}\r\n    </ul>\r\n</template>\r\n\r\n```\r\n\r\nNotice how we must use the `this` keyword to reference the *message* template, and how we use the *equal sign* to append the message string to the result of the *greet* template.\r\n\r\n\r\n\r\n### Template locations\r\n\r\nYou can define one or more templates inside the html document (for instance, inside a script element with the text attribute to something other than 'text/javascript'), or on an external file. For external files, use `fromURL(url, callback)` to load the external file asynchronously.\r\n\r\nWhen you need greater modularity, you can create multiple template files (or elements) and use them under the same namespace. You just need to declare them when loading your templates, using for instance `fromURL(['template1.html' ,'template2.html'], function(mytemplates) {});`.\r\n\r\nCheck the samples for more examples for loading templates and functions inline, or from external files.\r\n\r\n\r\n### Public functions\r\n\r\n* `fromID(id)`: Loads templates given an element ID (or array of IDs) and returns them as ready-to-use functions.\r\n\r\n* `fromURL(url, callback)`: Loads templates from an url (or array of urls) and returns them as ready-to-use functions.\r\n\r\n* `sourceFromID(id, namespace)`: Loads templates given an element ID (or array of IDs) and returns them as javascript source code with a given namespace, so that they can be used in production.\r\n\r\n* `sourceFromURL(url, namespace, callback)`: Loads templates from an url (or array of urls) and returns them as javascript source code with a given namespace, so that they can be used in production.\r\n\r\n* `build(string)`: Parses a string with templates and returns them as compiled javascript.\r\n\r\n* `buildString(string)`: Parses a string with templates and returns them as javascript source code.\r\n\r\n\r\n\r\n## Resources:\r\n\r\n* Github Page: http://joaoventura.github.io/temple.js/\r\n* Online generator: http://joaoventura.github.io/temple.js/generator/index.html\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}